<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tree on Amos的Blog</title>
    <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/</link>
    <description>Recent content in Tree on Amos的Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>xiayy860612@126.com (Amos Xia)</managingEditor>
    <webMaster>xiayy860612@126.com (Amos Xia)</webMaster>
    <lastBuildDate>Wed, 20 Jun 2018 11:46:54 +0000</lastBuildDate>
    
	<atom:link href="/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>BST二叉查找树</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/BST%E6%A0%91/</link>
      <pubDate>Fri, 15 Jun 2018 12:54:58 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/BST%E6%A0%91/</guid>
      <description>二叉查找树中每个结点X, 它的左子树中所有结点的值小于X结点中的值, 它的右子树中的所有结点的值大于X结点中的值. 即树中所有的元素以某种一致的方式排序.
二叉查找树的平均深度为O(logN), N为结点数.
二叉树的常用操作:
 查询, O(logN)  查询指定值的结点 查询最大/最小结点    </description>
    </item>
    
    <item>
      <title>平衡二叉树 AVL树</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/AVL%E6%A0%91/</link>
      <pubDate>Sat, 09 Jun 2018 08:57:11 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/AVL%E6%A0%91/</guid>
      <description> AVL树时带有平衡条件的二叉查找树. 这个平衡条件是每个结点的左子树和右子数的高度最多差1的二叉查找树(假设空树的高度为-1).
高度为h的AVL树中, 最少结点数S(h) = S(h-1) + S(h-2) + 1, 即最少结点左子树+最少结点右子树+根节点.
除了插入/删除操作, 绝大部分操作都可以以时间O(logN)来执行
插入/删除操作有可能会破坏树的平衡, 需要通过旋转来重新平衡
旋转针对的时被破坏了平衡部分的树, 通过旋转将破坏平衡的子树提升1层来重新达到平衡
树出现不平衡的情况:
 对左子树的左子树进行插入, 单旋转 对左子树的右子树进行插入, 双旋转 对右子树的左子树进行插入, 双旋转 对右子树的右子树进行插入, 单旋转  AVL树的高度 = max(左子树的高度, 右子树的高度) + 1
删除  立即删除结点 懒惰删除  </description>
    </item>
    
    <item>
      <title>树 &amp;&amp; 二叉树</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/Tree/</link>
      <pubDate>Thu, 07 Jun 2018 11:06:50 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/Tree/</guid>
      <description> 树的组成:
 节点(node)  根节点(root) 子节点(child) 叶节点(leaf)  边(edge)  树的路径是指一个节点到另一个节点之间的节点序列, 路径的长即为两个节点间的边的条数
节点的深度是指从根节点到指定节点的唯一路径的长.
节点的高是指从指定节点到树叶的最长路径的长.
树的应用:
 分层文件系统  树的遍历:
 前序遍历(pre-order), 先处理当前节点, 然后处理子节点, 最后兄弟节点 后序遍历(post-order), 先处理子节点, 然后当前节点, 最后兄弟节点  二叉树  每个节点最多2个子节点 二叉树的平均深度要比节点个数小的多, 为O(N的平方根)  二叉树查找树的运行时间为O(logN)
应用:
 编译器 表达式二叉树  二叉树的遍历:
 中序遍历(inorder), left, current, right 后序遍历(post-order), left, right, current 前序遍历(pre-order), current, left, right  </description>
    </item>
    
  </channel>
</rss>