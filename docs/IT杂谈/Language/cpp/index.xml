<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>cpp on Amos的Blog</title>
    <link>/it%E6%9D%82%E8%B0%88/language/cpp/</link>
    <description>Recent content in cpp on Amos的Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>xiayy860612@126.com (Amos Xia)</managingEditor>
    <webMaster>xiayy860612@126.com (Amos Xia)</webMaster>
    <lastBuildDate>Mon, 30 Apr 2018 13:28:12 +0000</lastBuildDate>
    
	<atom:link href="/it%E6%9D%82%E8%B0%88/language/cpp/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>C&#43;&#43; --- Smart Point</title>
      <link>/it%E6%9D%82%E8%B0%88/language/cpp/smart_point/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/it%E6%9D%82%E8%B0%88/language/cpp/smart_point/</guid>
      <description>It&amp;rsquo;s defined in  header file.
 shared ownership, shared_ptr exclusive ownership, unique_ptr  Shared Ownership Cannot use assignment(=) to initialize shared_ptr.
use make_share() to create object, it&amp;rsquo;s faster and safer coz it uses one allocations, not two:
 object allocation shared data used to control object  one shared_ptr contains 2 parts:
 object reference control object  if shared_ptr is used for array, define own deleter for array.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Advance Features</title>
      <link>/it%E6%9D%82%E8%B0%88/language/cpp/adv_feature_list/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/it%E6%9D%82%E8%B0%88/language/cpp/adv_feature_list/</guid>
      <description> High  Template Concurrency  async &amp;amp;&amp;amp; future threads promises   Low  Smart Point Convertor Type Traits Callable Objects  Lambda Functor  Allocators Timer Container  Element Iterator Algorithm  Regex I/O  </description>
    </item>
    
    <item>
      <title>Concurrency --- async &amp;&amp; Futures</title>
      <link>/it%E6%9D%82%E8%B0%88/language/cpp/async-future-promise/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/it%E6%9D%82%E8%B0%88/language/cpp/async-future-promise/</guid>
      <description>Hight Level Interface for Concurrency:
 std::async() std::future&amp;lt;&amp;gt; std::shared_future&amp;lt;&amp;gt;  async will try to start func immediately in a separate thread, at that time related func maybe start or not start.
async policy:
 std::launch::async, force to start immediately std::launch::deferred, start until get/wait invoked  assign async to future and use future to monitor progress.
invoke future.get() will raise one actions below:
 get result directly if related async func has been done block, won&amp;rsquo;t return result until related async func done force to start related async func and block, won&amp;rsquo;t return result until related async func done  the result could be an expected value or exception.</description>
    </item>
    
    <item>
      <title>Concurrency --- threads</title>
      <link>/it%E6%9D%82%E8%B0%88/language/cpp/threads/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/it%E6%9D%82%E8%B0%88/language/cpp/threads/</guid>
      <description>Unless really know what you are doing, you should pass all objects necessary by value, so that thread use only local copies.
when assign a func to thread, it will start directly or raise exception.
thread.join will block until done.
thread.detach will make thread run background.
Concurrency Data Access  mutex &amp;amp;&amp;amp; lock condition variable atomic  condition race, multiple threads access same object, someone modify it and some read it, it there is no control result will be undefined.</description>
    </item>
    
  </channel>
</rss>