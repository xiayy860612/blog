<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Amos的Blog</title>
    <link>/</link>
    <description>Recent content on Amos的Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <managingEditor>xiayy860612@126.com (Amos Xia)</managingEditor>
    <webMaster>xiayy860612@126.com (Amos Xia)</webMaster>
    <lastBuildDate>Wed, 20 Jun 2018 11:46:54 +0000</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Schema与数据类型优化</title>
      <link>/IT%E7%B2%BE%E5%8D%8E/Storage/MySQL/Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</link>
      <pubDate>Wed, 20 Jun 2018 09:36:21 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E7%B2%BE%E5%8D%8E/Storage/MySQL/Schema%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%BC%98%E5%8C%96/</guid>
      <description>数据类型的选择 MySQL基础数据类型
 数字  整数  tinyint/smallint/mediumint/int/bigint unsigned可选  实数  Float/Double, 浮点计算 DECIMAL, 存储精确的小数, 一般可使用bigint来代替decimal, 通过乘以相应的倍数即可   字符串  char, 定长, 适合更新频繁的列或者长度固定的列 varchar, 变长, 需要额外的1或2个字节来存储长度, 小于等于255则1个字节, 大于则2个字节; 不适合更新频繁的列, 会导致碎片化 text, 很长的字符串  二进制字符串, 比较时以字节为单位进行比较, 效率要比普通字符串要高  binary, 定长 varbinary, 变长 blob, 很长的二进制字符串  时间  datetime, 从1001到9999年, 精度为秒, 把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中, 显示与时区无关, 使用8字节存储 timestamp, 同unit时间戳, 从新纪元时间(1970-01-01T00:00:00)以来的秒数, 使用4字节存储, 只能表示1970到2038年, 显示依赖于时区, 会根据时区不同, 显示对应的时间; 对应的列默认为NOT NULL.   特殊数据类型的处理 uuid数据的处理:
 移除uuid中的- 使用unhex函数将uuid字符串转换为16字节的数字, 存储到binary(16)中 使用hex函数将16字节的数字转换为uuid字符串  mysql&amp;gt; select uuid(); +--------------------------------------+ | uuid() | +--------------------------------------+ | e8dc60bb-6df3-11e8-8915-0800273063ab | +--------------------------------------+ 1 row in set mysql&amp;gt; select unhex(&#39;e8dc60bb6df311e889150800273063ab&#39;); +-------------------------------------------+ | unhex(&#39;e8dc60bb6df311e889150800273063ab&#39;) | +-------------------------------------------+ | ��`�m�� +-------------------------------------------+ 1 row in set mysql&amp;gt; select hex(unhex(&#39;e8dc60bb6df311e889150800273063ab&#39;)); +------------------------------------------------+ | hex(unhex(&#39;e8dc60bb6df311e889150800273063ab&#39;)) | +------------------------------------------------+ | E8DC60BB6DF311E889150800273063AB | +------------------------------------------------+ 1 row in set  ip数据需要转换为数字存储:</description>
    </item>
    
    <item>
      <title>Java 常用特性</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/Java%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</link>
      <pubDate>Wed, 20 Jun 2018 07:31:33 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/Java%E5%B8%B8%E7%94%A8%E7%89%B9%E6%80%A7/</guid>
      <description>  Annotation 代理 IO NIO 多线程 集合 反射 异常处理机制 网络  Reference  JSR 133 内存模型和线程规范, 中文版   </description>
    </item>
    
    <item>
      <title>Java 书单</title>
      <link>/%E4%B9%A6%E5%8D%95/Java/</link>
      <pubDate>Wed, 20 Jun 2018 07:18:27 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/%E4%B9%A6%E5%8D%95/Java/</guid>
      <description> 初级 熟练掌握Java语法和基本特性, 并熟练使用Java以及相关的工具进行业务开发
 Java核心技术 卷I, 掌握Java基础以及基本特性 SQL必知必会, 快速掌握sql  中级 掌握Java的常用特性, 能够深入理解各种特性和相关工具的实现, 并对JVM有所了解
 Java并发编程实战, 深入理解Java的并发处理 高性能MySQL, 深入理解如何优化MySQL  高级 能够优化Java代码, 并能能够对JVM进行调优
Reference  Java核心必读书籍共享  </description>
    </item>
    
    <item>
      <title>创建LVM分区</title>
      <link>/IT%E6%9D%82%E8%B0%88/OS/linux/%E5%88%9B%E5%BB%BAlvm%E5%88%86%E5%8C%BA/</link>
      <pubDate>Wed, 20 Jun 2018 07:02:10 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/OS/linux/%E5%88%9B%E5%BB%BAlvm%E5%88%86%E5%8C%BA/</guid>
      <description>所有的操作尽量使用root来操作
从物理硬盘创建新分区, 格式化为LVM
$ fdisk /dev/sda Command: p Commond: n Command: t $ partprobe  使用新创建的分区来创建物理卷PV(Physical Volume)
$ pvscan $ pvcreate /dev/sda2 $ pvdisplay  建立卷组VG(Volume Group), 并关联到创建的PV上
$ vgcreate home-vg /dev/sda2  使用新建立的VG来建立逻辑卷LV(Logical Volume)
$ lvcreate -L 100G -n home-lv home-vg  格式化LV并挂在到系统中
$ mke2fs -t ext4 /dev/home-vg/home-lv $ mount -t ext4 /mnt/home /dev/home-vg/home-lv  启动时自动挂载在/etc/fstab文件进行设置, 加入下面的命令即可
/dev/mapper/home--vg-home--lv /home ext4 defaults 0 2  </description>
    </item>
    
    <item>
      <title>BST二叉查找树</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/BST%E6%A0%91/</link>
      <pubDate>Fri, 15 Jun 2018 12:54:58 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/BST%E6%A0%91/</guid>
      <description>二叉查找树中每个结点X, 它的左子树中所有结点的值小于X结点中的值, 它的右子树中的所有结点的值大于X结点中的值. 即树中所有的元素以某种一致的方式排序.
二叉查找树的平均深度为O(logN), N为结点数.
二叉树的常用操作:
 查询, O(logN)  查询指定值的结点 查询最大/最小结点    </description>
    </item>
    
    <item>
      <title>参考资源</title>
      <link>/IT%E6%9D%82%E8%B0%88/reference/</link>
      <pubDate>Thu, 14 Jun 2018 07:44:15 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/reference/</guid>
      <description> 开源社区  Stack Overflow OpenGenus  关注  Jerry Qu专注 WEB 端开发 阮一峰  </description>
    </item>
    
    <item>
      <title>多线程基础</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/common/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Wed, 13 Jun 2018 08:28:20 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/common/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</guid>
      <description>java.util.concurrent里提供了很多用于并发的组件.
可以传递给Thread进行异步执行的对象:
 Runnable, 用于封装没有参数和返回值的异步方法 Callable, 用于封装没有参数, 但有返回值的异步方法 Future, 保存了异步方法执行的状态和结果 FutureTask, 实现了Future和Runnable的接口, 可用来转换Callable到Runnable  Thread的6种状态变化
一个runnable状态的线程可能正在运行, 也可能没有运行.
实现UncaughtExceptionHandler接口, 然后可以通过setUncaughtExceptionHandler方法为线程指定异常处理器. 也可以通过Thread.setDefaultUncaughtExceptionHandler为所有线程设置默认的异常处理器.
同步 如果多个线程同时对某个数据进行请求, 则会产生竞争条件, 此时就需要通过同步的手段来使这些请求串行化处理.
Java的每个对象都有一个内部锁, 并且该锁有一个内部的条件变量.
Java的同步策咯:
 锁  synchronized方法, synchronized使用的就是对象的内部锁 ReentrantLock condition variable条件变量  同步阻塞, synchronized到对象, 显式加锁, 尽量保证锁的范围尽可能小 监视器 原子操作, java.util.concurrent.atomic提供了很多原子操作的工具 java.util.concurrent提供了线程安全的集合  任何集合类可以通过使用Collections.synchronizedXXX同步包装器方法变成线程安全. 但尽量使用java.util.concurrent提供的线程安全的集合, 而不是使用同步包装器方法.
List&amp;lt;E&amp;gt; list = Collection.synchronizedList(new ArrayList&amp;lt;E&amp;gt;()); Map&amp;lt;K, V&amp;gt; map = Collection.synchronizedMap(new HashMap&amp;lt;K, V&amp;gt;());  线程池 通过Executor执行器来创建线程池, 返回ExecutorService.
 newCachedThreadPool, 只在必要时创建新线程; 空闲线程只会保留一定时间后释放 newFixedThreadPool, 固定数量的线程 newScheduledThreadPool, 预定时间执行的固定线程池, 用来替代Timer来处理定时任务  当调用ExecutorService.</description>
    </item>
    
    <item>
      <title>平衡二叉树 AVL树</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/AVL%E6%A0%91/</link>
      <pubDate>Sat, 09 Jun 2018 08:57:11 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/AVL%E6%A0%91/</guid>
      <description> AVL树时带有平衡条件的二叉查找树. 这个平衡条件是每个结点的左子树和右子数的高度最多差1的二叉查找树(假设空树的高度为-1).
高度为h的AVL树中, 最少结点数S(h) = S(h-1) + S(h-2) + 1, 即最少结点左子树+最少结点右子树+根节点.
除了插入/删除操作, 绝大部分操作都可以以时间O(logN)来执行
插入/删除操作有可能会破坏树的平衡, 需要通过旋转来重新平衡
旋转针对的时被破坏了平衡部分的树, 通过旋转将破坏平衡的子树提升1层来重新达到平衡
树出现不平衡的情况:
 对左子树的左子树进行插入, 单旋转 对左子树的右子树进行插入, 双旋转 对右子树的左子树进行插入, 双旋转 对右子树的右子树进行插入, 单旋转  AVL树的高度 = max(左子树的高度, 右子树的高度) + 1
删除  立即删除结点 懒惰删除  </description>
    </item>
    
    <item>
      <title>Java 探索 --- Collection</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/collection/collection/</link>
      <pubDate>Fri, 08 Jun 2018 03:32:49 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/collection/collection/</guid>
      <description>Java中集合类的基本接口为Collection接口.
 List, 表示有序集合  ArrayList, 支持随机访问 LinkedList, 便于中间插入删除  Set  HashSet, 表示不重复无序集合, 可以快速查找元素, 通过自定义元素的hashCode和equals来去重 TreeSet, 有序集合, 通过自定义元素的Comparator接口来去重  Queue/Dequeue, 在队列头尾进行操作 Map, 存储键值对  HashMap TreeMap   Vector和ArrayList都是使用动态数组来实现, 但Vector是线程安全, 而ArrayList不是; 效率上ArrayList要优于Vector.
Hashtable和HashMap拥有相同的接口, Hashtable是线程安全, HashMap不是. 如果有并发访问的需求, 使用ConcurrentHashMap.
Collection通过使用Iterator迭代器来顺序访问集合中的元素, 元素被访问的顺序取决于集合类型.
 Collection&amp;lt;String&amp;gt; collection = new ArrayList&amp;lt;&amp;gt;(); collection.add(&amp;quot;hello&amp;quot;); collection.add(&amp;quot;world&amp;quot;); Iterator&amp;lt;String&amp;gt; it = collection.iterator(); while (it.hasNext()) { String next = it.next(); System.out.println(next); }  在Collection中间位置添加元素需要通过Iterator来进行插入.
ListIterator&amp;lt;String&amp;gt; listIterator = collection.listIterator(); listIterator.next(); listIterator.add(&amp;quot;yeyeye&amp;quot;);  Iterator的add只依赖于迭代器的位置, 而remove依赖于迭代器的状态, 不能连续多次调用.</description>
    </item>
    
    <item>
      <title>Java 类加载</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Fri, 08 Jun 2018 03:02:29 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
      <description>.class类文件存储了JVM的指令, JVM能够将JVM指令集转换为目标机器的机器语言.
JVM只加载程序执行时所需要的类文件.
类的解析是指加载某个类所以来的所有类的过程.
JVM加载类的大概流程:
 根据加载机制来加载类文件, 可以从本地磁盘, web远程等加载, 把获取到的字节码传递给虚拟机 类的解析 执行main方法 执行过程中加载更多的相关的类  类的加载机制会用到多个类加载器, 每个Java程序至少拥有3个类加载器:
 Bootstrap引导类加载器, 是JVM不可分割的一部分, 用于加载系统类, 通常从jre/lib/rt.jar中进行加载, 这部分加载的系统类没有对应的ClassLoader. Extension扩展类加载器, 从jre/lib/ext加载扩展类, 并且不会根据classpath进行加载类 System系统类加载器(又称应用类加载器), 用于加载开发人员实现的应用类, 从classpath设置的目录或者是jar文件里加载类  // String是系统类, 由Bootstrap加载 String.class.getClassLoader() // null  Extension类加载器和System类加载器都是URLClassLoader的实例.
类加载器有一种父-子关系, 除了Bootstrap类加载器, 每个类加载器都有一个父级的类加载器. 类加载器在加载一个类的时候, 首先交由父级类加载器来进行加载, 当父级类加载器没有找到对应的类时, 才由自己进行加载.
每个线程都有一个对类加载器的引用, 它被称为上下文类加载器. 主线程的上下文类加载器是System类加载器.
新线程创建时的上下文类加载器为创建该线程的上下文类加载器, 即如果没有显式去设定, 则所有线程都会使用System类加载器
 在应用程序代码中, 类是由包和类名来定位 在JVM中, 类是由类的全名(包和类名)和类加载器来确定的.  通过继承ClassLoader来实现自定义的类加载器.
 ClassLoader用于加载单个类 URLClassLoader可以加载类, 也可以加载类目录或者JAR文件  </description>
    </item>
    
    <item>
      <title>树 &amp;&amp; 二叉树</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/Tree/</link>
      <pubDate>Thu, 07 Jun 2018 11:06:50 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/Tree/Tree/</guid>
      <description> 树的组成:
 节点(node)  根节点(root) 子节点(child) 叶节点(leaf)  边(edge)  树的路径是指一个节点到另一个节点之间的节点序列, 路径的长即为两个节点间的边的条数
节点的深度是指从根节点到指定节点的唯一路径的长.
节点的高是指从指定节点到树叶的最长路径的长.
树的应用:
 分层文件系统  树的遍历:
 前序遍历(pre-order), 先处理当前节点, 然后处理子节点, 最后兄弟节点 后序遍历(post-order), 先处理子节点, 然后当前节点, 最后兄弟节点  二叉树  每个节点最多2个子节点 二叉树的平均深度要比节点个数小的多, 为O(N的平方根)  二叉树查找树的运行时间为O(logN)
应用:
 编译器 表达式二叉树  二叉树的遍历:
 中序遍历(inorder), left, current, right 后序遍历(post-order), left, right, current 前序遍历(pre-order), current, left, right  </description>
    </item>
    
    <item>
      <title>Spring 整体架构</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/spring/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</link>
      <pubDate>Thu, 07 Jun 2018 10:50:02 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/spring/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</guid>
      <description>核心7大模块:
 Spring Core, 实现了IOC Spring Context Spring AOP Spring DAO Spring ORM, 集成了JPA, MyBatis等 Spring Web Spring Web MVC  </description>
    </item>
    
    <item>
      <title>Java 8 新特性</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/Java8/%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Wed, 06 Jun 2018 13:25:44 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/Java8/%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description> Reference  Java 8 特性 – 终极手册 Java 8 新特性概述  </description>
    </item>
    
    <item>
      <title>Java 9 新特</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/Java9/%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Wed, 06 Jun 2018 13:25:39 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/Java9/%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description> Reference </description>
    </item>
    
    <item>
      <title>Java 10 新特性</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/Java10/%E6%96%B0%E7%89%B9%E6%80%A7/</link>
      <pubDate>Wed, 06 Jun 2018 13:25:35 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/Java10/%E6%96%B0%E7%89%B9%E6%80%A7/</guid>
      <description> Reference  Java 8 特性 – 终极手册 Java 8 新特性概述  </description>
    </item>
    
    <item>
      <title>Spring Boot --- 配置</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/spring/%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 06 Jun 2018 13:14:41 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/spring/%E9%85%8D%E7%BD%AE/</guid>
      <description>常用的配置方式, 优先级从高到低:
 命令行参数 系统环境变量 指定环境的profile文件, 主要application-{profile}.properties/yml 通用profile文件, 主要有application.properties/yml文件  profile配置文件  application.properties/yml, 通用配置 application-{profile}.properties/yml 自定义properties  profile配置文件可以放在以下位置, 优先级从高到低:
 resources/config目录 resources根目录  详情见: Application Property Files
通过spring.profiles.active={profile}来加载指定环境的profile配置文件
 spring.profiles.active=dev # 加载application-dev.properties  @Value 使用@Value(&amp;quot;${property_name}&amp;quot;)读取application.properties中的自定义配置
springboot-config.name=hello  // ValuableConfigParam @Component public class ValuableConfigParam { @Value(&amp;quot;${springboot-config.name}&amp;quot;) private String name; }  @ConfigurationProperties 通过指定前缀来自动解析配置
springboot-config.confprop.id=1 springboot-config.confprop.name=test  // ConfigPropertyParams @Component @ConfigurationProperties(prefix = &amp;quot;springboot-config.confprop&amp;quot;) public class ConfigPropertyParams { private Integer id; private String name; }  @PropertySource 读取自定义的配置</description>
    </item>
    
    <item>
      <title>时间的探索之旅 --- Java篇</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/%E6%97%B6%E9%97%B4/Time01/</link>
      <pubDate>Wed, 06 Jun 2018 13:13:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/%E6%97%B6%E9%97%B4/Time01/</guid>
      <description>不同的时间 时区 时间的表示方式  不同的时间  GMT UTC CST  GMT(Greenwich Mean Time), 格林尼治时间, 是英国伦敦的皇家格林威治天文台的标准时间, 因为它刚好在本初子午线经过的地方.
UTC(Coordinated Universal Time), 协调世界时
GMT是根据地球自转, 公转计算的(太阳每天经过英国伦敦皇家格林威治天文台的时间为中午12 点)，不是非常准确, UTC是经过平均太阳时(以格林威治时间GMT为准), 地轴运动修正后的新时标, 以及以秒为单位的国际原子时所综合精算而成的时间.
UTC比GMT来得更加精准, 一般都使用UTC时间, 而且在使用时, 两者一般被认为是相同的表示方式.
CST(China Standard Time), 中国标准时间, 即UTC+8, 东八区时间
时区 人们规定以子午线为中心，向东西两侧延伸，每 15 度划分一个时区，刚好是 24 个时区。 然后因为一天有 24 小时，地球自转一圈是 360 度，360 度 / 24 小时 = 15 度/小时， 所以每差一个时区，时间就差一个小时。
新纪元时间(epoch)的起点为穿过格林威治天文台的本初子午线所处时区(0时区)的1970.1.1 00:00:00.
人类时间:
 本地时间, 基于本地时区的时间, 包括本地的日期和时间 时区时间, 包括日期, 时间以及时区  时间的表示方式  时间戳, 从新纪元时间(epoch)到现在的时间差, 一般用毫秒ms来度量 ISO 8601, 格式YYYY-MM-DDTHH:mm:ss.</description>
    </item>
    
    <item>
      <title>String</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/String/</link>
      <pubDate>Wed, 06 Jun 2018 13:12:28 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/String/</guid>
      <description>字符串由char序列组成, char是采用的UTF-16编码的Unicode码.
String类对象是不可变对象, 对String对象的任何改变都不影响到原对象， 相关的任何change操作都会生成新的对象.
字符串比较:
 ==, 用来比较两个字符串的存储位置是否相同, 即检查是否同一个对象 equals, 用来比较两个字符串的值是否相等  字符串字面量存储在jvm虚拟机的常量池里, 能够快速读取, 只读.
// &amp;quot;hello&amp;quot;为字符串字面量, 存储在jvm的常量池里 String s0 = &amp;quot;hello&amp;quot;;  字符串的构建StringBuffer, StringBuilder String字符串可以通过+, contact来进行拼接生成一个新的String对象
 contact只能拼接字符串 使用+进行字符串拼接时, 不管后者是不是字符串, 总是会被转换为字符串, 但效率低, 会被编译器转换为StringBuilder来进行拼接  String s0 = &amp;quot;hello&amp;quot;; String s1 = s0 + 123; 反编译: 0: ldc #2	// String hello 2: astore_1 3: new #8	// class java/lang/StringBuilder 6: dup 7: invokespecial #9	// Method java/lang/StringBuilder.&amp;quot;&amp;lt;init&amp;gt;&amp;quot;:()V 10: aload_1 11: invokevirtual #10	// Method java/lang/StringBuilder.</description>
    </item>
    
    <item>
      <title>Java --- 时间探索</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/%E6%97%B6%E9%97%B4/Time02/</link>
      <pubDate>Wed, 06 Jun 2018 06:57:51 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/%E6%97%B6%E9%97%B4/Time02/</guid>
      <description>Java 8 引入了新的时间模块java.time, 以穿过英国格林尼治天文台的本初子午线所处时区(UTC+0时区)的 1970.1.1 00:00::00作为新纪元的时间原点, 通常称为epoch时间.
而Java的Instant表示以epoch为原点的时间线上的某个时间点, 是一个绝对时间.
见源码: public static Instant now() { return Clock.systemUTC().instant(); }  使用Duration来计算两个Instant之间的时间差.
Java有三种种时间
 绝对时间, 以epoch为原点的时间间隔, 通常用ms来描述  System.currentTimeMillis Instant  本地时间, 不包含时区信息, 只是纯粹的时间信息 时区时间, 包含时间信息和时区信息, 时区信息来源于IANA数据库  本地时间+时区 =&amp;gt; 时区时间 &amp;lt;=&amp;gt; Instant时间
// 本地时间 LocalDateTime date = LocalDateTime.of(year, month, day, hour, 0); System.out.println(date); // 本地时间不包含将时区信息, 可设置为任意时区, 但时间信息不会发生变化 ZonedDateTime zdt = date.atZone(ZoneId.of(&amp;quot;UTC+9&amp;quot;)); System.out.println(zdt); assertEquals(hour, zdt.getHour()); zdt = date.atZone(ZoneId.of(&amp;quot;UTC+7&amp;quot;)); System.out.println(zdt); assertEquals(hour, zdt.getHour());  时间的格式化 两种比较常用的时间标准</description>
    </item>
    
    <item>
      <title>阿里云---弹性伸缩</title>
      <link>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</link>
      <pubDate>Mon, 04 Jun 2018 10:34:39 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9/</guid>
      <description>弹性伸缩的资源:
 服务器 网络 存储  弹性伸缩的扩展方式:
 垂直扩展, 提升硬件配置 水平扩展, 增加单机的数量  弹性伸缩的优势:
 自动化 节约成本 容错性  阿里云的弹性伸缩可对ECS进行弹性伸缩:
 伸缩组 伸缩配置, 伸缩时的ECS实例的配置, 配置后不可修改 伸缩规则, 定义了具体的扩展或收缩的操作  </description>
    </item>
    
    <item>
      <title>Swagger 快速入门</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/swagger/swagger-basic/</link>
      <pubDate>Sat, 19 May 2018 16:27:06 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/swagger/swagger-basic/</guid>
      <description>Annotations</description>
    </item>
    
    <item>
      <title>swagger离线文档</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/swagger/swagger%E7%A6%BB%E7%BA%BF%E6%96%87%E6%A1%A3/</link>
      <pubDate>Sat, 19 May 2018 16:24:14 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/swagger/swagger%E7%A6%BB%E7%BA%BF%E6%96%87%E6%A1%A3/</guid>
      <description> 目前只可兼容springfox-swagger:2.6.1
Reference  SpringBoot项目生成RESTfull API的文档  </description>
    </item>
    
    <item>
      <title>背包问题</title>
      <link>/IT%E6%9D%82%E8%B0%88/Algorithm/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/package/</link>
      <pubDate>Wed, 16 May 2018 12:54:34 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Algorithm/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/package/</guid>
      <description> Reference  动态规划之01背包问题（最易理解的讲解）  </description>
    </item>
    
    <item>
      <title>Git</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/VersionControl/git/</link>
      <pubDate>Mon, 14 May 2018 13:16:56 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/VersionControl/git/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring --- 请求处理流程</title>
      <link>/IT%E7%B2%BE%E5%8D%8E/Framework/spring/request-workflow/request-workflow/</link>
      <pubDate>Mon, 14 May 2018 02:17:09 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E7%B2%BE%E5%8D%8E/Framework/spring/request-workflow/request-workflow/</guid>
      <description>Filter DispatcherServlet Interceptor HandlerAdapter  web程序启动时的初始化顺序: ServletContext -&amp;gt; listener -&amp;gt; filter -&amp;gt; servlet
spring bean的初始化是在listener中声明的, 可以在后面使用.
Filter  Servlet规范规定的，只能用于Web程序中, 由Servlet容器提供支持 作用于Servlet执行前后  @Order(1) @WebFilter(filterName = &amp;quot;customized&amp;quot;, urlPatterns = &amp;quot;/*&amp;quot;) public class CustomizedFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { log.info(&amp;quot;CustomizedFilter Init&amp;quot;); } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { log.info(&amp;quot;CustomizedFilter doFilter before&amp;quot;); // 执行Servlet filterChain.doFilter(servletRequest, servletResponse); log.info(&amp;quot;CustomizedFilter doFilter after&amp;quot;); } @Override public void destroy() { log.</description>
    </item>
    
    <item>
      <title>阿里云负载均衡SLB</title>
      <link>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/SLB/SLB/</link>
      <pubDate>Thu, 10 May 2018 15:01:30 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/SLB/SLB/</guid>
      <description>- SLB实例 - 监听规则 - 后端服务器
SLB提供的功能:
 支持公网和私网的负载均衡 4层和7层的负载均衡服务 调度方式  轮询模式, 依次转发给后端服务器 最小连接数模式, 转发给最小连接数的后端服务器 加权轮询, 根据后端权重来转发  会话保持 健康检查 单个实例同城灾备, 已经部署在同地域的不同可用区  </description>
    </item>
    
    <item>
      <title>WireMock</title>
      <link>/IT%E6%9D%82%E8%B0%88/QA/Wiremock/</link>
      <pubDate>Sun, 06 May 2018 08:50:49 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/QA/Wiremock/</guid>
      <description>服务的mock 录制/回放依赖服务的request/response 在集成测试时, 对第三方服务进行mock 支持state behavior进行串行行为测试  将录制和回放的数据分开
通过test case来对所有的接口进行录制</description>
    </item>
    
    <item>
      <title>Java实用工具</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/good_tools/</link>
      <pubDate>Thu, 03 May 2018 08:04:53 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/good_tools/</guid>
      <description> idea  lombok, 编译时自动生成attribute的get/set方法  </description>
    </item>
    
    <item>
      <title>阿里云 --- 存储</title>
      <link>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/OSS/OSS/</link>
      <pubDate>Wed, 02 May 2018 12:52:45 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/OSS/OSS/</guid>
      <description>RAID, 独立磁盘冗余阵列, 多块硬盘通过某种形式形成一定的数据冗余, 这样当一块或多块硬盘损坏时, 数据还能依靠冗余保存下来, 不至于丢失.
 RAID 0, 迅速读写, 安全性低 RAID 1, 随机数据写入, 安全性高 RAID 3, 连续数据传输, 安全性高 RAID 5, 随机数据传输, 安全性高  备份方式:
 增量备份 全量备份  灾备:
 同城灾备, 比较进行数据同步, 保证数据完整性和数据零丢失, 但无法避免自然大灾害 异地备份, 异地数据同步效率低下, 无法保证数据零丢失, 但可以避免自然大灾害 两地三中心, 结合同城+异地的优点, 是目前灾备系统的最佳实践  OSS 每个文件都是一个Object, 是OSS存储数据的基本单元, 每个Object包含key, data和meta data信息.
Object操作在OSS上具有原子性，操作要么成功要么失败，不会存在有中间状态的Object。OSS保证用户一旦上传完成之后读到的Object是完整的
Object都存储在Bucket中, Bucket在整个OSS中全局唯一且不可修改.
上传方式:
 客户端上传  简单上传, 不支持断点续传，适合用于上传小文件 表单上传 断点续传 追加上传  服务器上传, 上传走的内网, 不收取费用  简单上传 断点续传 追加上传   通过在querystring中添加x-oss-process来进行图片处理.</description>
    </item>
    
    <item>
      <title>Shiro --- 认证</title>
      <link>/IT%E6%9D%82%E8%B0%88/Web/auth/shiro/authentication/</link>
      <pubDate>Wed, 02 May 2018 06:04:17 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Web/auth/shiro/authentication/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Shiro --- 鉴权</title>
      <link>/IT%E6%9D%82%E8%B0%88/Web/auth/shiro/authorization/</link>
      <pubDate>Wed, 02 May 2018 06:03:45 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Web/auth/shiro/authorization/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Shiro</title>
      <link>/IT%E6%9D%82%E8%B0%88/Web/auth/shiro/shiro/</link>
      <pubDate>Wed, 02 May 2018 02:49:41 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Web/auth/shiro/shiro/</guid>
      <description> 大概的处理流程:
 Shiro Filter 获取token 使用token来进行Subject.login 通过Realm.supports来找到对应的Realm 将token传递给Realm.doGetAuthenticationInfo, 进行认证, 获取认证后的信息 将获取到的认证后的信息传递给Realm.doGetAuthorizationInfo, 进行鉴权, 获取角色和权限信息  Shiro的拦截器Filter 配置在ShiroFilterFactoryBean中
Reference  跟我学Shiro  </description>
    </item>
    
    <item>
      <title>阿里云 --- RDS</title>
      <link>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/RDS/RDS/</link>
      <pubDate>Tue, 01 May 2018 12:35:50 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Cloud/aliyun/RDS/RDS/</guid>
      <description>MySQL的相关架构
 单机的存储与计算分离架构 双机的一主一备热备架构 一主两备三节点架构, 通过日志多副本同步复制来确保数据的强一致性  RDS提供两种连接地址: 内网地址和外网地址, 两种访问模式: 标准模式和高安全模式
云上同一个地域的实例可以使用内网地址访问
使用多可用区来达到同城灾备
通过使用DMS来管理阿里云RDS
使用DTS来对数据进行迁移:
 结构迁移 全量数据迁移 增量数据迁移  RDS数据同步方式:
 半同步, 主库数据修改后, 会在保证数据同步到一定数量的备库后, 返回响应, 增加响应时间. 异步, 主库数据修改后, 立即返回响应, 不关心数据是否已经同步到备库. 如果主库宕机, 备库无法保证数据一致性.  </description>
    </item>
    
    <item>
      <title>.Net Introduction</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/dotnet-intro/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/dotnet-intro/</guid>
      <description>&lt;p&gt;学习&lt;a href=&#34;https://docs.microsoft.com/zh-cn/dotnet/articles/standard/&#34;&gt;.Net&lt;/a&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ASP.Net Core Introduction</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/asp.net-core-intro/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/asp.net-core-intro/</guid>
      <description>&lt;p&gt;ASP.Net Core 简介
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Async Programming Pattern</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/async-programming/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/async-programming/</guid>
      <description>&lt;p&gt;C#的异步编程模型
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Atom</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/Editor/atom/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/Editor/atom/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Backend Framework Structure</title>
      <link>/IT%E6%9D%82%E8%B0%88/Generic/be-framework-structure/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Generic/be-framework-structure/</guid>
      <description> 后端服务器框架的构建 基本组成  Host机制 Encrypt/Decrypt加密解密机制 配置管理 Authentication机制 Session管理 异常处理 路由管理 DTO接口管理 插件管理 Request Pipeline 序列化机制 日志系统 Task系统, 用于异步处理请求或定时任务 Request Cache  TCP  边界处理 连接管理  </description>
    </item>
    
    <item>
      <title>C# Generic</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/generic/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/generic/</guid>
      <description>&lt;hr /&gt;

&lt;p&gt;Official Site &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/512aeb7t.aspx&#34;&gt;C# Generic&lt;/a&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C# Regex Expression</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/regex/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/regex/</guid>
      <description>&lt;p&gt;C#使用Regex类来进行正则处理, 来自&lt;strong&gt;System.Text.RegularExpressions&lt;/strong&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C# Serialization</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/serialization/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/serialization/</guid>
      <description>&lt;p&gt;Serialization is used to allow data to be easily stored and transferred.&lt;/p&gt;

&lt;p&gt;It has tow directions
- Serialize, convert object into formatted data
- Deserialize, convert formatted data into object&lt;/p&gt;

&lt;p&gt;Remoting uses serialization to pass objects &amp;ldquo;&lt;strong&gt;by value&lt;/strong&gt;&amp;ldquo;
from one computer or application domain to another.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C&#43;&#43; --- Smart Point</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/cpp/smart_point/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/cpp/smart_point/</guid>
      <description>It&amp;rsquo;s defined in  header file.
 shared ownership, shared_ptr exclusive ownership, unique_ptr  Shared Ownership Cannot use assignment(=) to initialize shared_ptr.
use make_share() to create object, it&amp;rsquo;s faster and safer coz it uses one allocations, not two:
 object allocation shared data used to control object  one shared_ptr contains 2 parts:
 object reference control object  if shared_ptr is used for array, define own deleter for array.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; Advance Features</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/cpp/adv_feature_list/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/cpp/adv_feature_list/</guid>
      <description> High  Template Concurrency  async &amp;amp;&amp;amp; future threads promises   Low  Smart Point Convertor Type Traits Callable Objects  Lambda Functor  Allocators Timer Container  Element Iterator Algorithm  Regex I/O  </description>
    </item>
    
    <item>
      <title>CMake</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/build/cmake/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/build/cmake/</guid>
      <description>&lt;p&gt;Study &lt;a href=&#34;https://cmake.org/&#34;&gt;CMake&lt;/a&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cloud Introduction</title>
      <link>/IT%E6%9D%82%E8%B0%88/Virtual/cloud-intro/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Virtual/cloud-intro/</guid>
      <description> 云计算产生的原动力： - 芯片与硬件技术 - 资源虚拟化， 虚拟化技术是云计算中最关键，最核心的技术原动力。 - 面向服务架构(SOA), 资源和功能服务化是云计算的一个核心思想。 - 软件即服务(SAAS) - 互联网技术
云架构的服务层次： - IaaS, Infrastructure as a Service - PaaS, Platform as a Service - SaaS, Software as a Service
IaaS 基础设施层使经过虚拟化后的计算资源、存储资源和网络资源能够 以基础设施即服务的方式通过网络被用户使用和管理。
基本功能  资源抽象, 常见的资源抽象模型：  虚拟机，Virtual Machine 集群，Cluster 虚拟数据中心，Virtual Data Center 云，Cloud  资源监控  Amazon CloudWatch  负载管理，提供自动化的负载平衡机制将负载进行合并，使得所有的资源在整体负载和整体利用率上趋于平衡 数据管理，在云计算中，必须要保证数据的完整性，可靠性以及可管理性。 资源部署 安全管理 计费管理  存储虚拟化技术  IBM SAN Volume Controller IBM Tivoli Storage Manager(TSM) Google File System Hadoop Distributed File System VMWare Virtual Machine System  Reference  虚拟化与云计算， ISBN 978-7-121-09678-5 世界是平的，托马斯*费里德曼 SOA, Service Oriented Architecture SaaS, Software as a Service RIA，Rich Internet Application 富互联网应用 Xen虚拟化技术  </description>
    </item>
    
    <item>
      <title>Concurrency - [Thread][Managed Threading]</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/thread/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/thread/</guid>
      <description>&lt;p&gt;.Net provides some &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/hh156548(v=vs.110).aspx&#34;&gt;Concurrency Mechanisms&lt;/a&gt; such like &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/3e8s7xdd(v=vs.110).aspx&#34;&gt;Managed Thread&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Concurrency --- async &amp;&amp; Futures</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/cpp/async-future-promise/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/cpp/async-future-promise/</guid>
      <description>Hight Level Interface for Concurrency:
 std::async() std::future&amp;lt;&amp;gt; std::shared_future&amp;lt;&amp;gt;  async will try to start func immediately in a separate thread, at that time related func maybe start or not start.
async policy:
 std::launch::async, force to start immediately std::launch::deferred, start until get/wait invoked  assign async to future and use future to monitor progress.
invoke future.get() will raise one actions below:
 get result directly if related async func has been done block, won&amp;rsquo;t return result until related async func done force to start related async func and block, won&amp;rsquo;t return result until related async func done  the result could be an expected value or exception.</description>
    </item>
    
    <item>
      <title>Concurrency --- threads</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/cpp/threads/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/cpp/threads/</guid>
      <description>Unless really know what you are doing, you should pass all objects necessary by value, so that thread use only local copies.
when assign a func to thread, it will start directly or raise exception.
thread.join will block until done.
thread.detach will make thread run background.
Concurrency Data Access  mutex &amp;amp;&amp;amp; lock condition variable atomic  condition race, multiple threads access same object, someone modify it and some read it, it there is no control result will be undefined.</description>
    </item>
    
    <item>
      <title>Concurrency in Practice</title>
      <link>/IT%E6%9D%82%E8%B0%88/Concurrency/Concurrency-in-Practice/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Concurrency/Concurrency-in-Practice/</guid>
      <description>&lt;p&gt;介绍如何安全使用并发，以及哪些情况是不安全的用例。
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Configuration</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/servicestack/configuration/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/servicestack/configuration/</guid>
      <description>&lt;p&gt;理解ServiceStack中的&lt;a href=&#34;http://docs.servicestack.net/appsettings&#34;&gt;Configuration&lt;/a&gt;的设计
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Configuration</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/configuration/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/configuration/</guid>
      <description>&lt;p&gt;Configuration Managemnet Implement in C#.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dispose Pattern</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/dispose-pattern/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/dispose-pattern/</guid>
      <description>&lt;p&gt;Developers must be careful when using such system resources,
because they must be released after they have been acquired and used.&lt;/p&gt;

&lt;p&gt;So we need use &lt;a href=&#34;https://msdn.microsoft.com/en-us/library/b1yfkh5e.aspx&#34;&gt;Dispose Pattern&lt;/a&gt;
to help release these resources.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ECMAScript Introduction</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/javascript/ecmascript-intro/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/javascript/ecmascript-intro/</guid>
      <description>ECMAScript是由ECMA-262标准化的脚本语言的名称， 弱类型的语言，可以为不同种类的宿主环境提供核心的脚本编程能力.
JavaScript由3部分组成： - ECMAScript，作为JavaScript的核心， 描述了该语言的语法和基本对象。 - DOM - BOM  2011.6，ECMAScript 5.1 2015.6，ECMAScript 6  变量名需要遵守两条简单的规则： - 第一个字符必须是字母、下划线（_）或美元符号（$） - 余下的字符可以是下划线、美元符号或任何字母或数字字符
 ECMAScript 的解释程序遇到未声明过的标识符时， 用该变量名创建一个全局变量，并将其初始化为指定的值。 undefined表示声明了变量但未对其初始化时赋予该变量的值 null表示尚未存在的对象 NaN表示非数(Not a Number), 一般发生在类型(String, Boolean等)转换失败时; NaN 的另一个奇特之处在于，它与自身不相等 变量可以存在两种类型的值，即原始值和引用值。  原始值，存储在栈（stack）中的简单数据段， 也就是说，它们的值直接存储在变量访问的位置。 引用值， 存储在堆（heap）中的对象， 也就是说，存储在变量处的值是一个指针（point），指向存储对象的内存处。  原始类型：Undefined、Null、Boolean、Number 和 String，原始类型占据的空间是固定的 类的2个属性，类的属性和方法的绑定为晚绑定  constructor用于创建实例 prototype用于定义类的属性和方法  类的定义和创建  混合的构造函数/原型方式 动态原型方法  类的继承  对象冒充 原型链, 用另一类型的对象重写类的prototype属性 对象冒充和原型链混合   let and const ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量， 从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</description>
    </item>
    
    <item>
      <title>ELK-Filebeat</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/ELK/filebeat/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/ELK/filebeat/</guid>
      <description>&lt;p&gt;Filebeat is a log data shipper.
Installed as an agent on your servers,
Filebeat monitors the log directories or specific log files,
tails the files, and forwards them either to Elasticsearch or Logstash for indexing.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/IT杂谈/Tools/ELK/filebeat.png&#34; alt=&#34;Filebeat&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Elixir Introduction</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/elixir-intro/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/elixir-intro/</guid>
      <description>&lt;p&gt;Elixir 是一个基于Erlang虚拟机的函数式、面向并行的通用编程语言。
Elixir 以 Erlang 为基础，支持分布式、高容错、实时应用程序的开发，
同时亦对其进行扩展使之借助宏实现元编程，并通过协议支持多态。&lt;/p&gt;

&lt;p&gt;More Details on &lt;a href=&#34;http://elixir-lang.org/getting-started/introduction.html&#34;&gt;Introduction&lt;/a&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Event &amp;&amp; Delegate</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/event-delegate/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/event-delegate/</guid>
      <description>&lt;p&gt;Events in the .NET Framework are based on the delegate model.
The delegate model follows the observer design pattern,
which enables a subscriber to register with, and receive notifications from, a provider.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>FAQ</title>
      <link>/IT%E6%9D%82%E8%B0%88/CI/jenkins/FAQ/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/CI/jenkins/FAQ/</guid>
      <description> docker运行jenkins 两种常见挂载Jenkins slave节点的方法  </description>
    </item>
    
    <item>
      <title>Future &amp;&amp; Promise</title>
      <link>/IT%E6%9D%82%E8%B0%88/Generic/Future-Promise/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Generic/Future-Promise/</guid>
      <description> Future Future是一种用于指代某个尚未就绪的值而被当成 只读占位符 的对象类型。 而这个值，往往是某个计算过程的结果:
 若该计算过程尚未完成，我们就说该Future未就位 若该计算过程正常结束，或中途抛出异常，我们就说该Future已就位。  Future的就位分为两种情况:
 计算成功 抛出异常  Future只能被赋值一次. 一旦给定了某个值或某个异常，future对象就变成了不可变对象——无法再被改写。
Future是一种特殊的Event，它只能被计算一次，而Event可以被reset，然后重新使用。
Promise Promise是 可写的，用于构建Future，一旦构建则不能更改。
一个 Future 实例总是和一个（也只能是一个）Promise 实例关联在一起, 以确保 Promise 和 Future 之间一对一的关系。
Reference  Wiki &amp;mdash; Futures and promises Future 实战中的 Promise 和 Future  </description>
    </item>
    
    <item>
      <title>GNU make</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/build/make/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/build/make/</guid>
      <description>&lt;p&gt;通过配置Makefile, 使用make对C++工程进行构建
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Gradle</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/build/gradle/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/build/gradle/</guid>
      <description>&lt;p&gt;Study &lt;a href=&#34;https://gradle.org/&#34;&gt;Gradle&lt;/a&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java --- Generic泛型</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/java/generic/generic/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/java/generic/generic/</guid>
      <description>泛型的好处:
 更好的可读性 更好的安全性  泛型的类型参数使的程序具有更好的可读性和安全性.
类型变量是泛型的固定类型, 用来指示泛型中所使用的具体类型.
泛型方法的类型变量放在修饰符的后面, 返回类型的前面.
class ArrayAlg { public static &amp;lt;T&amp;gt; getMid(T arg) {...} } // 调用时, 在方法名前的尖括号中放入具体的类型 ArrayAlg.&amp;lt;String&amp;gt;getMid(&amp;quot;hello&amp;quot;); // 同上, 编译器有足够信息进行类型推断 ArrayAlg.getMid(&amp;quot;hello&amp;quot;);  类型变量的限定
// 单个限定 T extends Type1 // 多个限定 T extends Type1 &amp;amp; Type2  Java的继承中, 类型变量可以有多个接口类型, 但最多只能有一个类. 如果用类作为限定, 必须放在限定列表第一个.
Java虚拟机没有泛型类型对象, 都是普通类.
Java通过类型擦除的方式提供对泛型的支持.
当定义一个泛型类型时, 都会产生一个相应的原始类型(raw type), 原始类型就是删去类型参数后的类型名, 擦除类型变量并替换为限定类型, 如果没有限定类型, 则使用Object作为限定类型.
// Java定义的类型 @Getter @Setter public class Pair&amp;lt;T&amp;gt; { private T first; private T second; public Pair() { this.</description>
    </item>
    
    <item>
      <title>Logstash</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/ELK/logstash/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/ELK/logstash/</guid>
      <description>&lt;p&gt;学习Logstash
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Model Binding</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/model-binding/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/model-binding/</guid>
      <description>&lt;p&gt;Research &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/model-binding&#34;&gt;Model Binding&lt;/a&gt; in ASP.Net Core
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MySQL Programming</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/mysql-programming/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/mysql-programming/</guid>
      <description>&lt;p&gt;介绍C#中如何使用MySQL Connect和MySQL进行交互
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Netty 介绍</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/netty/intro/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/netty/intro/</guid>
      <description>&lt;p&gt;NIO网络框架
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python之Sublime Text3 配置</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/Editor/python-env-sublime3/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/Editor/python-env-sublime3/</guid>
      <description>&lt;p&gt;Python在Sublime Text3中的配置
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>RESTful</title>
      <link>/IT%E6%9D%82%E8%B0%88/Web/restful/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Web/restful/</guid>
      <description> Reference </description>
    </item>
    
    <item>
      <title>Real-Time Server Framework - Photon</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/photon/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/photon/</guid>
      <description>Photon可用于构建实时性的游戏服务器。 可用于构建Load Balance或者MMO Server。
Official Site: https://www.photonengine.com/en-US/ Basic Knowledge ApplicationBase It used to set up an server application and create connection peers.
Importance Interface: - PeerBase CreatePeer(InitRequest initRequest), when a new connection comes, this function will be raised. - void Setup() - void TearDown()
Connect Peer It represents a connection with server application. Process all communications and status updates in peer.
Each kind of peer should inherit from PeerBase. There are some different kind of Peers: - ClientPeer, Client-Server Peer + Peer - S2SPeerBase, Server-Server Peer + InboundS2SPeer + OutboundS2SPeer</description>
    </item>
    
    <item>
      <title>Redis 参考文章</title>
      <link>/IT%E6%9D%82%E8%B0%88/Storage/redis/ref/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Storage/redis/ref/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Router</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/router/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/router/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>SOAP Protocol</title>
      <link>/IT%E6%9D%82%E8%B0%88/Web/soap/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Web/soap/</guid>
      <description>&lt;p&gt;SOAP(Simple Object Access Protocol), 简单对象访问协议,
是交换数据的一种协议规范, 使用在web service中交换带结构信息.&lt;/p&gt;

&lt;p&gt;目前SOAP 1.1版是业界共同的标准,属于第二代的XML协定(第一代具代表性的技术为XML-RPC以及WDDX).
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Serializer</title>
      <link>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/serializer/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Framework/asp.net/serializer/</guid>
      <description>&lt;p&gt;Research &lt;a href=&#34;https://docs.microsoft.com/en-us/aspnet/core/mvc/models/formatting&#34;&gt;Serializer&lt;/a&gt; in ASP.Net Core.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Stream</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/stream/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/stream/</guid>
      <description>&lt;p&gt;C#中的&lt;a href=&#34;https://msdn.microsoft.com/en-US/library/k3352a4t.aspx&#34;&gt;Stream处理机制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;System.IO&lt;/strong&gt; namespace contains types related to stream read/write.
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Sublime Text3 环境配置</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/Editor/sublime-text3-config/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/Editor/sublime-text3-config/</guid>
      <description>&lt;p&gt;Sublime Text3 环境配置
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Type System</title>
      <link>/IT%E6%9D%82%E8%B0%88/Language/csharp/type-system/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Language/csharp/type-system/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://msdn.microsoft.com/en-us/library/zcx1eb1e.aspx&#34;&gt;Type System&lt;/a&gt; in C#
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ubuntu --- 创建用户和组</title>
      <link>/IT%E6%9D%82%E8%B0%88/OS/linux/commands/create_user/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/OS/linux/commands/create_user/</guid>
      <description> useradd, 创建用户  /etc/passwd  groupadd, 创建组  /etc/   </description>
    </item>
    
    <item>
      <title>Yaml</title>
      <link>/IT%E6%9D%82%E8%B0%88/Generic/yaml/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Generic/yaml/</guid>
      <description>&lt;p&gt;Study &lt;a href=&#34;http://yaml.org/&#34;&gt;Yaml&lt;/a&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Yaml</title>
      <link>/IT%E6%9D%82%E8%B0%88/Tools/Configuration/yaml/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Tools/Configuration/yaml/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://yaml.org/&#34;&gt;Yaml&lt;/a&gt; for configuration
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>好文推荐</title>
      <link>/IT%E6%9D%82%E8%B0%88/good-article/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/good-article/</guid>
      <description> 时间  关于“时间”的一次探索  技术博文  跟我学Shiro Swagger从入门到精通  </description>
    </item>
    
    <item>
      <title>常用命令</title>
      <link>/IT%E6%9D%82%E8%B0%88/OS/linux/usefull-command/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/OS/linux/usefull-command/</guid>
      <description>&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>认证方式 --- OAuth</title>
      <link>/IT%E6%9D%82%E8%B0%88/Web/auth/oauth/</link>
      <pubDate>Mon, 30 Apr 2018 13:28:12 +0000</pubDate>
      <author>xiayy860612@126.com (Amos Xia)</author>
      <guid>/IT%E6%9D%82%E8%B0%88/Web/auth/oauth/</guid>
      <description> Reference  理解OAuth 2.0 关于 RESTFUL API 安全认证方式的一些总结  </description>
    </item>
    
  </channel>
</rss>